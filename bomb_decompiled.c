/* This file was generated by the Hex-Rays decompiler version 7.7.0.220118.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

__int64 (**init_proc())(void);
void sub_DF0();
// char *getenv(const char *name);
// int *__errno_location(void);
// char *strcpy(char *dest, const char *src);
// int puts(const char *s);
// ssize_t write(int fd, const void *buf, size_t n);
// unsigned int alarm(unsigned int seconds);
// int close(int fd);
// ssize_t read(int fd, void *buf, size_t nbytes);
// char *fgets(char *s, int n, FILE *stream);
// __sighandler_t signal(int sig, __sighandler_t handler);
// struct hostent *gethostbyname(const char *name);
// __int64 __fastcall __memmove_chk(_QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 strtol(const char *nptr, char **endptr, int base);
// int fflush(FILE *stream);
// __int64 __isoc99_sscanf(_QWORD, const char *, ...); weak
// __int64 __printf_chk(_QWORD, const char *, ...); weak
// FILE *fopen(const char *filename, const char *modes);
// void __noreturn exit(int status);
// int connect(int fd, const struct sockaddr *addr, socklen_t len);
// __int64 __fprintf_chk(_QWORD, _QWORD, const char *, ...); weak
// unsigned int sleep(unsigned int seconds);
// const unsigned __int16 **__ctype_b_loc(void);
// __int64 __sprintf_chk(_QWORD, _QWORD, _QWORD, const char *, ...); weak
// int socket(int domain, int type, int protocol);
// int __fastcall _cxa_finalize(void *);
void __fastcall __noreturn start(__int64 a1, __int64 a2, void (*a3)(void));
FILE **deregister_tm_clones();
__int64 register_tm_clones(void); // weak
FILE **_do_global_dtors_aux();
__int64 __fastcall frame_dummy(_QWORD, _QWORD, _QWORD); // weak
int __cdecl main(int argc, const char **argv, const char **envp);
__int64 __fastcall phase_1(_BYTE *a1);
unsigned __int64 __fastcall phase_2(__int64 a1);
unsigned __int64 __fastcall phase_3(__int64 a1);
__int64 __fastcall func4(__int64 a1, __int64 a2, __int64 a3);
unsigned __int64 __fastcall phase_4(__int64 a1);
unsigned __int64 __fastcall phase_5(__int64 a1);
unsigned __int64 __fastcall phase_6(__int64 a1);
__int64 __fastcall fun7(__int64 a1, int a2);
unsigned __int64 secret_phase();
void __noreturn sig_handler();
void __fastcall __noreturn invalid_phase(const char *a1);
__int64 __fastcall string_length(_BYTE *a1);
__int64 __fastcall strings_not_equal(_BYTE *a1, _BYTE *a2);
__sighandler_t initialize_bomb();
__int64 __fastcall blank_line(char *a1);
char *skip();
void __fastcall __noreturn explode_bomb(_QWORD); // weak
__int64 __fastcall read_six_numbers(__int64 a1, __int64 a2);
const char *read_line();
unsigned __int64 phase_defused();
void __noreturn sigalrm_handler();
__int64 __fastcall rio_readlineb(__int64 a1, _BYTE *a2, unsigned __int64 a3);
__int64 __fastcall submitr(char *name, __int16 a2, const char *a3, const char *a4, const char *a5, const char *a6, const char *a7, char *a8);
unsigned int __fastcall init_timeout(int seconds);
__int64 __fastcall init_driver(char *a1);
__int64 __fastcall driver_post(const char *a1, const char *a2, const char *a3, int a4, char *a5);
void _libc_csu_fini(void); // idb
void term_proc();
// int __fastcall _libc_start_main(int (__fastcall *main)(int, char **, char **), int argc, char **ubp_av, void (*init)(void), void (*fini)(void), void (*rtld_fini)(void), void *stack_end);
// int __fastcall __cxa_finalize(void *);
// __int64 _gmon_start__(void); weak

//-------------------------------------------------------------------------
// Data declarations

int dword_0 = 1179403647; // weak
_UNKNOWN _libc_csu_init;
_DWORD array_3416[16] = { 10, 2, 14, 7, 8, 12, 15, 11, 0, 4, 1, 13, 3, 9, 6, 5 }; // weak
__int64 (__fastcall *_frame_dummy_init_array_entry)() = &frame_dummy; // weak
__int64 (__fastcall *_do_global_dtors_aux_fini_array_entry)() = &_do_global_dtors_aux; // weak
void *_dso_handle = &_dso_handle; // idb
_UNKNOWN n1; // weak
_UNKNOWN node1; // weak
FILE *_bss_start; // idb
__int64 stdin; // weak
__int64 stderr; // weak
char completed_7698; // weak
int num_input_strings; // weak
FILE *infile; // idb
char input_strings[240]; // weak
_UNKNOWN unk_204790; // weak


//----- (0000000000000DD0) ----------------------------------------------------
__int64 (**init_proc())(void)
{
  __int64 (**result)(void); // rax

  result = &_gmon_start__;
  if ( &_gmon_start__ )
    return (__int64 (**)(void))_gmon_start__();
  return result;
}
// 204E18: using guessed type __int64 _gmon_start__(void);

//----- (0000000000000DF0) ----------------------------------------------------
void sub_DF0()
{
  JUMPOUT(0LL);
}
// DF6: control flows out of bounds to 0

//----- (0000000000000FA0) ----------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall __noreturn start(__int64 a1, __int64 a2, void (*a3)(void))
{
  __int64 v3; // rax
  int v4; // esi
  __int64 v5; // [rsp-8h] [rbp-8h] BYREF
  char *retaddr; // [rsp+0h] [rbp+0h] BYREF

  v4 = v5;
  v5 = v3;
  _libc_start_main(
    (int (__fastcall *)(int, char **, char **))main,
    v4,
    &retaddr,
    (void (*)(void))_libc_csu_init,
    _libc_csu_fini,
    a3,
    &v5);
  __halt();
}
// FA6: positive sp value 8 has been found
// FAD: variable 'v3' is possibly undefined

//----- (0000000000000FD0) ----------------------------------------------------
FILE **deregister_tm_clones()
{
  return &_bss_start;
}

//----- (0000000000001010) ----------------------------------------------------
__int64 register_tm_clones()
{
  return 0LL;
}
// 1010: using guessed type __int64 __fastcall register_tm_clones();

//----- (0000000000001060) ----------------------------------------------------
FILE **_do_global_dtors_aux()
{
  FILE **result; // rax

  if ( !completed_7698 )
  {
    if ( &__cxa_finalize )
      _cxa_finalize(_dso_handle);
    result = deregister_tm_clones();
    completed_7698 = 1;
  }
  return result;
}
// 204688: using guessed type char completed_7698;

//----- (00000000000010A0) ----------------------------------------------------
__int64 frame_dummy()
{
  return register_tm_clones();
}
// 1010: using guessed type __int64 register_tm_clones(void);
// 10A0: using guessed type __int64 __fastcall frame_dummy();

//----- (00000000000010AA) ----------------------------------------------------
int __cdecl main(int argc, const char **argv, const char **envp)
{
  __int64 line; // rax
  __int64 v4; // rax
  __int64 v5; // rax
  __int64 v6; // rax
  __int64 v7; // rax
  __int64 v8; // rdi

  if ( argc == 1 )
  {
    infile = (FILE *)stdin;
  }
  else
  {
    if ( argc != 2 )
    {
      __printf_chk(1LL, "Usage: %s [<input_file>]\n", *argv);
      exit(8);
    }
    infile = fopen(argv[1], "r");
    if ( !infile )
    {
      __printf_chk(1LL, "%s: Error: Couldn't open %s\n", *argv, argv[1]);
      exit(8);
    }
  }
  initialize_bomb();
  puts("Welcome to my fiendish little bomb. You have 6 phases with");
  puts("which to blow yourself up. Have a nice day!");
  line = read_line();
  phase_1(line);
  phase_defused();
  puts("Phase 1 defused. How about the next one?");
  v4 = read_line();
  phase_2(v4);
  phase_defused();
  puts("That's number 2.  Keep going!");
  v5 = read_line();
  phase_3(v5);
  phase_defused();
  puts("Halfway there!");
  v6 = read_line();
  phase_4(v6);
  phase_defused();
  puts("So you got that one.  Try this one.");
  v7 = read_line();
  phase_5(v7);
  phase_defused();
  puts("Good work!  On to the next...");
  v8 = read_line();
  phase_6(v8);
  phase_defused();
  return 0;
}
// F00: using guessed type __int64 __printf_chk(_QWORD, const char *, ...);
// 1204: using guessed type __int64 __fastcall phase_1(_QWORD);
// 1224: using guessed type __int64 __fastcall phase_2(_QWORD);
// 128D: using guessed type __int64 __fastcall phase_3(_QWORD);
// 143B: using guessed type __int64 __fastcall phase_4(_QWORD);
// 14B0: using guessed type __int64 __fastcall phase_5(_QWORD);
// 1543: using guessed type __int64 __fastcall phase_6(_QWORD);
// 1802: using guessed type __int64 initialize_bomb(void);
// 190E: using guessed type __int64 read_line(void);
// 1A52: using guessed type __int64 phase_defused(void);
// 204670: using guessed type __int64 stdin;

//----- (0000000000001204) ----------------------------------------------------
__int64 __fastcall phase_1(_BYTE *a1)
{
  __int64 result; // rax

  result = strings_not_equal(a1, "I turned the moon into something I call a Death Star.");
  if ( (_DWORD)result )
    explode_bomb();
  return result;
}
// 18A7: using guessed type void __noreturn explode_bomb(void);

//----- (0000000000001224) ----------------------------------------------------
unsigned __int64 __fastcall phase_2(__int64 a1)
{
  int *v1; // rbx
  int v3[5]; // [rsp+0h] [rbp-38h] BYREF
  int v4; // [rsp+14h] [rbp-24h] BYREF
  unsigned __int64 v5; // [rsp+18h] [rbp-20h]

  v5 = __readfsqword(0x28u);
  read_six_numbers(a1, (__int64)v3);
  if ( v3[0] != 1 )
    explode_bomb();
  v1 = v3;
  do
  {
    if ( v1[1] != 2 * *v1 )
      explode_bomb();
    ++v1;
  }
  while ( v1 != &v4 );
  return __readfsqword(0x28u) ^ v5;
}
// 18A7: using guessed type void __noreturn explode_bomb(void);

//----- (000000000000128D) ----------------------------------------------------
unsigned __int64 __fastcall phase_3(__int64 a1)
{
  char v1; // al
  unsigned __int64 result; // rax
  char v3; // [rsp+Fh] [rbp-19h] BYREF
  int v4; // [rsp+10h] [rbp-18h] BYREF
  int v5; // [rsp+14h] [rbp-14h] BYREF
  unsigned __int64 v6; // [rsp+18h] [rbp-10h]

  v6 = __readfsqword(0x28u);
  if ( (int)__isoc99_sscanf(a1, "%d %c %d", &v4, &v3, &v5) <= 2 )
    explode_bomb();
  switch ( v4 )
  {
    case 0:
      v1 = 120;
      if ( v5 != 698 )
        explode_bomb();
      return result;
    case 1:
      v1 = 117;
      if ( v5 != 766 )
        explode_bomb();
      return result;
    case 2:
      v1 = 118;
      if ( v5 != 728 )
        explode_bomb();
      return result;
    case 3:
      v1 = 118;
      if ( v5 != 218 )
        explode_bomb();
      return result;
    case 4:
      v1 = 122;
      if ( v5 != 535 )
        explode_bomb();
      return result;
    case 5:
      v1 = 101;
      if ( v5 != 615 )
        explode_bomb();
      return result;
    case 6:
      v1 = 105;
      if ( v5 != 163 )
        explode_bomb();
      return result;
    case 7:
      v1 = 97;
      if ( v5 != 449 )
        explode_bomb();
      return result;
    default:
      explode_bomb();
  }
  if ( v3 != v1 )
    explode_bomb();
  return __readfsqword(0x28u) ^ v6;
}
// EF0: using guessed type __int64 __isoc99_sscanf(_QWORD, const char *, ...);
// 18A7: using guessed type void __noreturn explode_bomb(void);

//----- (0000000000001407) ----------------------------------------------------
__int64 __fastcall func4(__int64 a1, __int64 a2, __int64 a3)
{
  int v3; // ebx

  v3 = a2 + ((int)a3 - (int)a2) / 2;
  if ( v3 > (int)a1 )
  {
    v3 += func4(a1, a2, (unsigned int)(v3 - 1));
  }
  else if ( v3 < (int)a1 )
  {
    v3 += func4(a1, (unsigned int)(v3 + 1), a3);
  }
  return (unsigned int)v3;
}

//----- (000000000000143B) ----------------------------------------------------
unsigned __int64 __fastcall phase_4(__int64 a1)
{
  unsigned int v2; // [rsp+0h] [rbp-18h] BYREF
  int v3; // [rsp+4h] [rbp-14h] BYREF
  unsigned __int64 v4; // [rsp+8h] [rbp-10h]

  v4 = __readfsqword(0x28u);
  if ( (unsigned int)__isoc99_sscanf(a1, "%d %d", &v2, &v3) != 2 || v2 > 0xE )
    explode_bomb();
  if ( (unsigned int)func4(v2, 0LL, 14LL) != 21 || v3 != 21 )
    explode_bomb();
  return __readfsqword(0x28u) ^ v4;
}
// EF0: using guessed type __int64 __isoc99_sscanf(_QWORD, const char *, ...);
// 18A7: using guessed type void __noreturn explode_bomb(void);

//----- (00000000000014B0) ----------------------------------------------------
unsigned __int64 __fastcall phase_5(__int64 a1)
{
  int v1; // eax
  int v2; // ecx
  int v3; // edx
  int v5; // [rsp+0h] [rbp-18h] BYREF
  int v6; // [rsp+4h] [rbp-14h] BYREF
  unsigned __int64 v7; // [rsp+8h] [rbp-10h]

  v7 = __readfsqword(0x28u);
  if ( (int)__isoc99_sscanf(a1, "%d %d", &v5, &v6) <= 1 )
    ((void (__noreturn *)(void))explode_bomb)();
  v1 = v5 & 0xF;
  v5 = v1;
  if ( v1 == 15 )
    goto LABEL_7;
  v2 = 0;
  v3 = 0;
  do
  {
    ++v3;
    v1 = array_3416[v1];
    v2 += v1;
  }
  while ( v1 != 15 );
  v5 = 15;
  if ( v3 != 15 || v6 != v2 )
LABEL_7:
    explode_bomb(a1);
  return __readfsqword(0x28u) ^ v7;
}
// EF0: using guessed type __int64 __isoc99_sscanf(_QWORD, const char *, ...);
// 18A7: using guessed type void __fastcall __noreturn explode_bomb(_QWORD);
// 2940: using guessed type _DWORD array_3416[16];

//----- (0000000000001543) ----------------------------------------------------
unsigned __int64 __fastcall phase_6(__int64 a1)
{
  int *v1; // r12
  int v2; // r13d
  int v3; // ebx
  _QWORD *v4; // rdx
  int v5; // eax
  __int64 i; // rsi
  int v7; // ecx
  __int64 v8; // rbx
  __int64 v9; // rax
  __int64 v10; // rdx
  __int64 v11; // rax
  __int64 v12; // rdx
  __int64 v13; // rax
  int v14; // ebp
  int v16[8]; // [rsp+0h] [rbp-88h] BYREF
  __int64 v17; // [rsp+20h] [rbp-68h]
  __int64 v18; // [rsp+28h] [rbp-60h]
  __int64 v19; // [rsp+30h] [rbp-58h]
  __int64 v20; // [rsp+38h] [rbp-50h]
  __int64 v21; // [rsp+40h] [rbp-48h]
  __int64 v22; // [rsp+48h] [rbp-40h]
  unsigned __int64 v23; // [rsp+58h] [rbp-30h]

  v23 = __readfsqword(0x28u);
  v1 = v16;
  read_six_numbers(a1, (__int64)v16);
  v2 = 0;
  while ( 1 )
  {
    if ( (unsigned int)(*v1 - 1) > 5 )
      explode_bomb(a1);
    if ( ++v2 == 6 )
      break;
    v3 = v2;
    do
    {
      if ( *v1 == v16[v3] )
        explode_bomb(a1);
      ++v3;
    }
    while ( v3 <= 5 );
    ++v1;
  }
  for ( i = 0LL; i != 6; ++i )
  {
    v7 = v16[i];
    v5 = 1;
    v4 = &node1;
    if ( v7 > 1 )
    {
      do
      {
        v4 = (_QWORD *)v4[1];
        ++v5;
      }
      while ( v5 != v7 );
    }
    *(&v17 + i) = (__int64)v4;
  }
  v8 = v17;
  v9 = v18;
  *(_QWORD *)(v17 + 8) = v18;
  v10 = v19;
  *(_QWORD *)(v9 + 8) = v19;
  v11 = v20;
  *(_QWORD *)(v10 + 8) = v20;
  v12 = v21;
  *(_QWORD *)(v11 + 8) = v21;
  v13 = v22;
  *(_QWORD *)(v12 + 8) = v22;
  *(_QWORD *)(v13 + 8) = 0LL;
  v14 = 5;
  do
  {
    if ( *(_DWORD *)v8 > **(_DWORD **)(v8 + 8) )
      explode_bomb(a1);
    v8 = *(_QWORD *)(v8 + 8);
    --v14;
  }
  while ( v14 );
  return __readfsqword(0x28u) ^ v23;
}
// 18A7: using guessed type void __fastcall __noreturn explode_bomb(_QWORD);
// 1543: using guessed type int var_88[8];

//----- (0000000000001665) ----------------------------------------------------
__int64 __fastcall fun7(__int64 a1, int a2)
{
  __int64 result; // rax

  if ( !a1 )
    return 0xFFFFFFFFLL;
  if ( *(_DWORD *)a1 > a2 )
    return 2 * (unsigned int)fun7(*(_QWORD *)(a1 + 8));
  result = 0LL;
  if ( *(_DWORD *)a1 != a2 )
    return 2 * (unsigned int)fun7(*(_QWORD *)(a1 + 16)) + 1;
  return result;
}

//----- (00000000000016A4) ----------------------------------------------------
unsigned __int64 secret_phase()
{
  const char *line; // rdi
  int v1; // ebx

  line = read_line();
  v1 = strtol(line, 0LL, 10);
  if ( (unsigned int)(v1 - 1) > 0x3E8 )
    explode_bomb(line);
  if ( (unsigned int)fun7((__int64)&n1, v1) != 5 )
    explode_bomb(&n1);
  puts("Wow! You've defused the secret stage!");
  return phase_defused();
}
// 18A7: using guessed type void __fastcall __noreturn explode_bomb(_QWORD);

//----- (00000000000016FB) ----------------------------------------------------
void __noreturn sig_handler()
{
  puts("So you think you can stop the bomb with ctrl-c, do you?");
  sleep(3u);
  __printf_chk(1LL, "Well...");
  fflush(_bss_start);
  sleep(1u);
  puts("OK. :-)");
  exit(16);
}
// F00: using guessed type __int64 __printf_chk(_QWORD, const char *, ...);

//----- (0000000000001757) ----------------------------------------------------
void __fastcall __noreturn invalid_phase(const char *a1)
{
  __printf_chk(1LL, "Invalid phase%s\n", a1);
  exit(8);
}
// F00: using guessed type __int64 __printf_chk(_QWORD, const char *, ...);

//----- (000000000000177E) ----------------------------------------------------
__int64 __fastcall string_length(_BYTE *a1)
{
  _BYTE *v1; // rdx
  __int64 result; // rax

  if ( !*a1 )
    return 0LL;
  v1 = a1;
  do
    result = (unsigned int)((_DWORD)++v1 - (_DWORD)a1);
  while ( *v1 );
  return result;
}

//----- (000000000000179B) ----------------------------------------------------
__int64 __fastcall strings_not_equal(_BYTE *a1, _BYTE *a2)
{
  _BYTE *v2; // rbx
  _BYTE *v3; // rbp
  int v4; // r12d
  int v5; // eax
  unsigned int v6; // edx

  v2 = a1;
  v3 = a2;
  v4 = string_length(a1);
  v5 = string_length(a2);
  v6 = 1;
  if ( v4 == v5 )
  {
    if ( *a1 )
    {
      if ( *a1 == *a2 )
      {
        while ( 1 )
        {
          ++v2;
          ++v3;
          if ( !*v2 )
            break;
          if ( *v3 != *v2 )
            return 1;
        }
        return 0;
      }
      else
      {
        return 1;
      }
    }
    else
    {
      return 0;
    }
  }
  return v6;
}

//----- (0000000000001802) ----------------------------------------------------
__sighandler_t initialize_bomb()
{
  return signal(2, (__sighandler_t)sig_handler);
}

//----- (000000000000181E) ----------------------------------------------------
__int64 __fastcall blank_line(char *a1)
{
  char v2; // bl

  while ( 1 )
  {
    v2 = *a1;
    if ( !*a1 )
      break;
    ++a1;
    if ( ((*__ctype_b_loc())[v2] & 0x2000) == 0 )
      return 0LL;
  }
  return 1LL;
}

//----- (0000000000001859) ----------------------------------------------------
char *skip()
{
  char *v0; // rax
  char *v1; // rbx

  do
  {
    v0 = fgets(&input_strings[80 * num_input_strings], 80, infile);
    v1 = v0;
  }
  while ( v0 && (unsigned int)blank_line(v0) );
  return v1;
}
// 20468C: using guessed type int num_input_strings;

//----- (00000000000018A7) ----------------------------------------------------
void __noreturn explode_bomb()
{
  puts("\nBOOM!!!");
  puts("The bomb has blown up.");
  exit(8);
}
// 18A7: using guessed type void __fastcall __noreturn explode_bomb();

//----- (00000000000018CD) ----------------------------------------------------
__int64 __fastcall read_six_numbers(__int64 a1, __int64 a2)
{
  __int64 result; // rax

  result = __isoc99_sscanf(a1, "%d %d %d %d %d %d", a2, a2 + 4, a2 + 8, a2 + 12, a2 + 16, a2 + 20);
  if ( (int)result <= 5 )
    explode_bomb();
  return result;
}
// EF0: using guessed type __int64 __isoc99_sscanf(_QWORD, const char *, ...);
// 18A7: using guessed type void __noreturn explode_bomb(void);

//----- (000000000000190E) ----------------------------------------------------
const char *read_line()
{
  int v0; // esi
  const char *v1; // rdx
  unsigned __int64 v2; // kr08_8
  int v4; // eax

  if ( !skip() )
  {
    if ( infile == (FILE *)stdin )
    {
      puts("Error: Premature EOF on stdin");
      exit(8);
    }
    if ( getenv("GRADE_BOMB") )
      exit(0);
    infile = (FILE *)stdin;
    if ( !skip() )
    {
      puts("Error: Premature EOF on stdin");
      exit(0);
    }
  }
  v0 = num_input_strings;
  v1 = &input_strings[80 * num_input_strings];
  v2 = strlen(v1) + 1;
  if ( (int)v2 - 1 > 78 )
  {
    puts("Error: Input line too long");
    v4 = num_input_strings++;
    strcpy(&input_strings[80 * v4], "***truncated***");
    explode_bomb(0x2A2A2A64657461LL);
  }
  input_strings[80 * num_input_strings - 2 + (int)v2] = 0;
  num_input_strings = v0 + 1;
  return v1;
}
// 18A7: using guessed type void __fastcall __noreturn explode_bomb(_QWORD);
// 204670: using guessed type __int64 stdin;
// 20468C: using guessed type int num_input_strings;

//----- (0000000000001A52) ----------------------------------------------------
unsigned __int64 phase_defused()
{
  char v1; // [rsp+8h] [rbp-70h] BYREF
  char v2; // [rsp+Ch] [rbp-6Ch] BYREF
  char v3[88]; // [rsp+10h] [rbp-68h] BYREF
  unsigned __int64 v4; // [rsp+68h] [rbp-10h]

  v4 = __readfsqword(0x28u);
  if ( num_input_strings == 6 )
  {
    if ( (unsigned int)__isoc99_sscanf(&unk_204790, "%d %d %s", &v1, &v2, v3) == 3
      && !(unsigned int)strings_not_equal(v3, "DrEvil") )
    {
      puts("Curses, you've found the secret phase!");
      puts("But finding it and solving it are quite different...");
      secret_phase();
    }
    puts("Congratulations! You've defused the bomb!");
  }
  return __readfsqword(0x28u) ^ v4;
}
// EF0: using guessed type __int64 __isoc99_sscanf(_QWORD, const char *, ...);
// 16A4: using guessed type __int64 secret_phase(void);
// 179B: using guessed type __int64 __fastcall strings_not_equal(_QWORD, _QWORD);
// 20468C: using guessed type int num_input_strings;

//----- (0000000000001AF7) ----------------------------------------------------
void __noreturn sigalrm_handler()
{
  __fprintf_chk(stderr, 1LL, "Program timed out after %d seconds\n", 0LL);
  exit(1);
}
// F40: using guessed type __int64 __fprintf_chk(_QWORD, _QWORD, const char *, ...);
// 204680: using guessed type __int64 stderr;

//----- (0000000000001B27) ----------------------------------------------------
__int64 __fastcall rio_readlineb(__int64 a1, _BYTE *a2, unsigned __int64 a3)
{
  int v5; // r13d
  void *v6; // rbp
  int v7; // eax
  int v8; // eax
  char *v9; // rdx
  char v10; // cl
  __int64 result; // rax
  int v12; // eax

  v5 = 1;
  v6 = (void *)(a1 + 16);
  if ( a3 <= 1 )
    goto LABEL_10;
  while ( 1 )
  {
    while ( 1 )
    {
      while ( 1 )
      {
        v7 = *(_DWORD *)(a1 + 4);
        if ( v7 <= 0 )
          break;
        v9 = *(char **)(a1 + 8);
        v10 = *v9;
        *(_QWORD *)(a1 + 8) = v9 + 1;
        *(_DWORD *)(a1 + 4) = v7 - 1;
        *a2++ = v10;
        if ( v10 != 10 && ++v5 < a3 )
          continue;
        goto LABEL_10;
      }
      v8 = read(*(_DWORD *)a1, v6, 0x2000uLL);
      *(_DWORD *)(a1 + 4) = v8;
      if ( v8 >= 0 )
        break;
      if ( *__errno_location() != 4 )
      {
        v12 = -1;
        goto LABEL_13;
      }
    }
    if ( !v8 )
      break;
    *(_QWORD *)(a1 + 8) = v6;
  }
  v12 = 0;
LABEL_13:
  if ( v12 )
    return -1LL;
  result = 0LL;
  if ( v5 != 1 )
  {
LABEL_10:
    *a2 = 0;
    return v5;
  }
  return result;
}

//----- (0000000000001BE3) ----------------------------------------------------
__int64 __fastcall submitr(
        char *name,
        __int16 a2,
        const char *a3,
        const char *a4,
        const char *a5,
        const char *a6,
        const char *a7,
        char *a8)
{
  const char *v8; // rbx
  int v9; // eax
  int v10; // r12d
  struct hostent *v11; // rax
  unsigned __int64 v12; // kr18_8
  char *v13; // rbp
  __int64 v14; // r13
  int v16; // r8d
  char *v17; // r13
  size_t v18; // rbp
  ssize_t v19; // rax
  unsigned __int64 v20; // rcx
  __int64 v21; // rbx
  unsigned int v26; // [rsp+3Ch] [rbp-A06Ch] BYREF
  struct sockaddr addr; // [rsp+40h] [rbp-A068h] BYREF
  int v28[2]; // [rsp+50h] [rbp-A058h] BYREF
  __int64 *v29; // [rsp+58h] [rbp-A050h]
  __int64 v30; // [rsp+60h] [rbp-A048h] BYREF
  char src[8192]; // [rsp+2060h] [rbp-8048h] BYREF
  char v32[16384]; // [rsp+4060h] [rbp-6048h] BYREF
  char v33[8200]; // [rsp+8060h] [rbp-2048h] BYREF
  unsigned __int64 v34; // [rsp+A068h] [rbp-40h]

  v8 = a7;
  v34 = __readfsqword(0x28u);
  v26 = 0;
  v9 = socket(2, 1, 0);
  if ( v9 < 0 )
  {
    strcpy(a8, "Error: Client unable to create socket");
    return 0xFFFFFFFFLL;
  }
  v10 = v9;
  v11 = gethostbyname(name);
  if ( !v11 )
  {
    strcpy(a8, "Error: DNS is unable to resolve server address");
    close(v10);
    return 0xFFFFFFFFLL;
  }
  *(_QWORD *)addr.sa_data = 0LL;
  *(_DWORD *)&addr.sa_data[8] = 0;
  *(_WORD *)&addr.sa_data[12] = 0;
  addr.sa_family = 2;
  __memmove_chk(&addr.sa_data[2], *v11->h_addr_list, v11->h_length, 12LL);
  *(_WORD *)addr.sa_data = __ROR2__(a2, 8);
  if ( connect(v10, &addr, 0x10u) < 0 )
  {
    strcpy(a8, "Error: Unable to connect to the server");
    close(v10);
    return 0xFFFFFFFFLL;
  }
  if ( strlen(a4) + 1 + strlen(a3) + 2 + strlen(a6) + 2 + 3 * (strlen(a7) + 1) - 3 + 123 > 0x2000 )
  {
    strcpy(a8, "Error: Result string too large. Increase SUBMITR_MAXBUF");
    close(v10);
    return 0xFFFFFFFFLL;
  }
  memset(v32, 0, 0x2000uLL);
  v12 = strlen(a7) + 1;
  if ( (_DWORD)v12 != 1 )
  {
    v13 = v32;
    v14 = 0x2000000000FFD9LL;
    do
    {
      v16 = *(unsigned __int8 *)v8;
      if ( (unsigned __int8)(v16 - 42) <= 0x35u && _bittest64(&v14, (unsigned int)(v16 - 42))
        || (unsigned __int8)((v16 & 0xDF) - 65) <= 0x19u )
      {
        *v13++ = v16;
      }
      else if ( (_BYTE)v16 == 32 )
      {
        *v13++ = 43;
      }
      else
      {
        if ( (unsigned __int8)(v16 - 32) > 0x5Fu && (_BYTE)v16 != 9 )
        {
          strcpy(a8, "Error: Result string contains an illegal or unprintable character.");
          close(v10);
          return 0xFFFFFFFFLL;
        }
        __sprintf_chk(v33, 1LL, 8LL, "%%%02X", (unsigned __int8)v16);
        *v13 = v33[0];
        v13[1] = v33[1];
        v13[2] = v33[2];
        v13 += 3;
      }
      ++v8;
    }
    while ( v8 != &a7[(unsigned int)(v12 - 2) + 1] );
  }
  __sprintf_chk(
    src,
    1LL,
    0x2000LL,
    "GET /%s/submitr.pl/?userid=%s&userpwd=%s&lab=%s&result=%s&submit=submit HTTP/1.0\r\n\r\n",
    a3,
    a4,
    a5,
    a6,
    v32);
  v20 = strlen(src) + 1;
  v21 = v20 - 1;
  v18 = v20 - 1;
  v17 = src;
  if ( v20 == 1 )
  {
LABEL_26:
    v28[0] = v10;
    v28[1] = 0;
    v29 = &v30;
    if ( rio_readlineb((__int64)v28, src, 0x2000uLL) <= 0 )
    {
      strcpy(a8, "Error: Client unable to read first header from server");
      close(v10);
      return 0xFFFFFFFFLL;
    }
    else
    {
      __isoc99_sscanf(src, "%s %d %[a-zA-z ]", &v32[0x2000], &v26, v33);
      if ( v26 == 200 )
      {
        while ( strcmp(src, "\r\n") )
        {
          if ( rio_readlineb((__int64)v28, src, 0x2000uLL) <= 0 )
          {
            strcpy(a8, "Error: Client unable to read headers from server");
            close(v10);
            return 0xFFFFFFFFLL;
          }
        }
        if ( rio_readlineb((__int64)v28, src, 0x2000uLL) <= 0 )
        {
          strcpy(a8, "Error: Client unable to read status message from server");
          close(v10);
          return 0xFFFFFFFFLL;
        }
        else
        {
          strcpy(a8, src);
          close(v10);
          return (unsigned int)-(strcmp(a8, "OK") != 0);
        }
      }
      else
      {
        __sprintf_chk(a8, 1LL, -1LL, "Error: HTTP request failed with error %d: %s", v26, v33);
        close(v10);
        return 0xFFFFFFFFLL;
      }
    }
  }
  else
  {
    do
    {
      v19 = write(v10, v17, v18);
      if ( v19 <= 0 )
      {
        if ( *__errno_location() != 4 )
          goto LABEL_31;
        v19 = 0LL;
      }
      v17 += v19;
      v18 -= v19;
    }
    while ( v18 );
    if ( v21 >= 0 )
      goto LABEL_26;
LABEL_31:
    strcpy(a8, "Error: Client unable to write to the server");
    close(v10);
    return 0xFFFFFFFFLL;
  }
}
// EC0: using guessed type __int64 __fastcall __memmove_chk(_QWORD, _QWORD, _QWORD, _QWORD);
// EF0: using guessed type __int64 __isoc99_sscanf(_QWORD, const char *, ...);
// F70: using guessed type __int64 __sprintf_chk(_QWORD, _QWORD, _QWORD, const char *, ...);

//----- (0000000000002424) ----------------------------------------------------
unsigned int __fastcall init_timeout(int seconds)
{
  unsigned int v2; // edi
  unsigned int result; // eax

  if ( seconds )
  {
    signal(14, (__sighandler_t)sigalrm_handler);
    v2 = 0;
    if ( seconds >= 0 )
      v2 = seconds;
    return alarm(v2);
  }
  return result;
}

//----- (000000000000244F) ----------------------------------------------------
__int64 __fastcall init_driver(char *a1)
{
  int v1; // eax
  int v2; // ebx
  struct hostent *v3; // rax
  struct sockaddr v5; // [rsp+0h] [rbp-38h] BYREF
  unsigned __int64 v6; // [rsp+18h] [rbp-20h]

  v6 = __readfsqword(0x28u);
  signal(13, (__sighandler_t)((char *)&dword_0 + 1));
  signal(29, (__sighandler_t)((char *)&dword_0 + 1));
  signal(29, (__sighandler_t)((char *)&dword_0 + 1));
  v1 = socket(2, 1, 0);
  if ( v1 < 0 )
  {
    strcpy(a1, "Error: Client unable to create socket");
    return 0xFFFFFFFFLL;
  }
  else
  {
    v2 = v1;
    v3 = gethostbyname("changeme.ics.cs.cmu.edu");
    if ( v3 )
    {
      *(_QWORD *)v5.sa_data = 0LL;
      *(_DWORD *)&v5.sa_data[8] = 0;
      *(_WORD *)&v5.sa_data[12] = 0;
      v5.sa_family = 2;
      __memmove_chk(&v5.sa_data[2], *v3->h_addr_list, v3->h_length, 12LL);
      *(_WORD *)v5.sa_data = 28219;
      if ( connect(v2, &v5, 0x10u) < 0 )
      {
        __sprintf_chk(a1, 1LL, -1LL, "Error: Unable to connect to server %s", "changeme.ics.cs.cmu.edu");
        close(v2);
        return 0xFFFFFFFFLL;
      }
      else
      {
        close(v2);
        strcpy(a1, "OK");
        return 0LL;
      }
    }
    else
    {
      strcpy(a1, "Error: DNS is unable to resolve server address");
      close(v2);
      return 0xFFFFFFFFLL;
    }
  }
}
// 0: using guessed type int dword_0;
// EC0: using guessed type __int64 __fastcall __memmove_chk(_QWORD, _QWORD, _QWORD, _QWORD);
// F70: using guessed type __int64 __sprintf_chk(_QWORD, _QWORD, _QWORD, const char *, ...);

//----- (0000000000002658) ----------------------------------------------------
__int64 __fastcall driver_post(const char *a1, const char *a2, const char *a3, int a4, char *a5)
{
  if ( a4 )
  {
    __printf_chk(1LL, "\nAUTORESULT_STRING=%s\n", a3);
    strcpy(a5, "OK");
    return 0LL;
  }
  else if ( a1 && *a1 )
  {
    return submitr("changeme.ics.cs.cmu.edu", 15214, "csapp", a1, a2, "bomblab", a3, a5);
  }
  else
  {
    strcpy(a5, "OK");
    return 0LL;
  }
}
// F00: using guessed type __int64 __printf_chk(_QWORD, const char *, ...);

//----- (00000000000026D0) ----------------------------------------------------
void __fastcall _libc_csu_init(unsigned int a1, __int64 a2, __int64 a3)
{
  signed __int64 v4; // rbp
  __int64 i; // rbx

  v4 = &_do_global_dtors_aux_fini_array_entry - &_frame_dummy_init_array_entry;
  init_proc();
  if ( v4 )
  {
    for ( i = 0LL; i != v4; ++i )
      ((void (__fastcall *)(_QWORD, __int64, __int64))*(&_frame_dummy_init_array_entry + i))(a1, a2, a3);
  }
}
// 10A0: using guessed type __int64 __fastcall frame_dummy(_QWORD, _QWORD, _QWORD);
// 203CF8: using guessed type __int64 (__fastcall *_frame_dummy_init_array_entry)();
// 203D00: using guessed type __int64 (__fastcall *_do_global_dtors_aux_fini_array_entry)();

//----- (0000000000002744) ----------------------------------------------------
void term_proc()
{
  ;
}

// nfuncs=92 queued=36 decompiled=36 lumina nreq=0 worse=0 better=0
// ALL OK, 36 function(s) have been successfully decompiled
